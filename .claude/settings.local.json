{
  "permissions": {
    "allow": [
      "Bash(gcloud container security-patches describe:*)",
      "Bash(gcloud container security-bulletins:*)",
      "Bash(gcloud compute security-bulletins list:*)",
      "Bash(gcloud container get-server-config:*)",
      "Bash(gcloud beta container security-bulletins list:*)",
      "WebSearch",
      "Bash(cat:*)",
      "Bash(gcloud projects list:*)",
      "Bash(gcloud config get-value:*)",
      "Bash(for project in skywide-backup spice-385121)",
      "Bash(do)",
      "Bash(echo:*)",
      "Bash(gcloud compute instances list:*)",
      "Bash(gcloud storage buckets list:*)",
      "Bash(gcloud run services list:*)",
      "Bash(gcloud functions list:*)",
      "Bash(done)",
      "Bash(gcloud compute instances describe:*)",
      "Bash(gcloud compute addresses:*)",
      "Bash(gcloud compute disks list:*)",
      "Bash(gcloud compute snapshots:*)",
      "Bash(gcloud storage ls:*)",
      "Bash(while read bucket)",
      "Bash(do echo \"Bucket: $bucket\")",
      "Bash(gcloud storage:*)",
      "Bash(gcloud artifacts repositories list:*)",
      "Bash(gcloud billing accounts list:*)",
      "Bash(gcloud billing projects list:*)",
      "Bash(gcloud services list:*)",
      "Bash(gcloud billing accounts describe:*)",
      "Bash(bq ls:*)",
      "Bash(gcloud services enable:*)",
      "Bash(gcloud alpha billing accounts describe:*)",
      "Bash(gcloud logging sinks:*)",
      "Bash(/Users/akash/Library/Python/3.9/bin/detect-secrets scan:*)",
      "Bash(python3:*)",
      "Bash(cloudflared --version:*)",
      "Bash(cloudflared tunnel:*)",
      "Bash(dig:*)",
      "Bash(nslookup:*)",
      "Bash(cloudflared tunnel list:*)",
      "Bash(git add:*)",
      "Bash(git commit -m \"$\\(cat <<''EOF''\nfeat: add Cloudflare Tunnel HA infrastructure\n\nTerraform module:\n- cloudflare_tunnel resource with random secret\n- cloudflare_tunnel_config for ingress rules\n- cloudflare_record for CNAME DNS records\n- Outputs tunnel_token for Ansible deployment\n\nAnsible role:\n- Install cloudflared from Cloudflare APT repo\n- Systemd service using --token authentication\n- Staged deployment playbook for public nodes\n\nKubernetes workspace:\n- Add cloudflare and random providers\n- Add cloudflare_account_id and zone_id variables\n- Wire up cloudflare-tunnel module\n\nðŸ¤– Generated with [Claude Code]\\(https://claude.com/claude-code\\)\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(git push:*)",
      "Bash(gh pr create --title \"feat: add Cloudflare Tunnel HA infrastructure \\(GitOps\\)\" --body \"$\\(cat <<''EOF''\n## Summary\n- Add Terraform module for Cloudflare Tunnel management \\(`terraform-modules/cloudflare-tunnel/`\\)\n- Add Ansible role for cloudflared deployment \\(`ansible/roles/cloudflared/`\\)\n- Add deployment playbook for public nodes\n- Wire up module in kubernetes workspace with new providers and variables\n\n## Architecture\n```\nInternet â†’ Cloudflare Edge â†’ cloudflared \\(pam OR angela OR toby\\) â†’ ingress-nginx â†’ k8s Service â†’ Pod\n```\n\nThree cloudflared instances provide automatic failover via Cloudflare''s health-based routing.\n\n## What Terraform manages\n- `cloudflare_tunnel` - Creates tunnel with random secret\n- `cloudflare_tunnel_config` - Ingress rules \\(hostnames â†’ localhost:80\\)\n- `cloudflare_record` - CNAME DNS records to tunnel\n\n## Prerequisites before merge\n1. Add `cloudflare_account_id` variable to Terraform Cloud kubernetes workspace\n2. Add `cloudflare_zone_id` variable \\(for shrub.dev zone\\)\n3. Ensure API token has `Cloudflare Tunnel:Edit` permission\n\n## Post-merge steps\n1. `terraform apply` to create tunnel\n2. Get token: `terraform output -raw cloudflare_tunnel_token`\n3. Deploy cloudflared: `ansible-playbook -i ansible/hosts.ini ansible/playbooks/cloudflared.yml -e \"cloudflared_tunnel_token=$TOKEN\"`\n\n## Test plan\n- [ ] Terraform plan shows tunnel, config, and DNS record creation\n- [ ] Terraform apply succeeds\n- [ ] Ansible deploys cloudflared to public nodes\n- [ ] Services accessible via tunnel\n- [ ] Failover works \\(stop cloudflared on one node, service still works\\)\n\nðŸ¤– Generated with [Claude Code]\\(https://claude.com/claude-code\\)\nEOF\n\\)\")",
      "Bash(git commit:*)",
      "Bash(npx markdownlint-cli:*)",
      "Bash(gh pr create --title \"fix: delete existing DNS records before creating tunnel CNAMEs\" --body \"$\\(cat <<''EOF''\n## Summary\n- Add `terraform_data` resource with `local-exec` provisioner to delete conflicting DNS records\n- This handles the case where external-dns created A records that conflict with tunnel CNAMEs\n- Required because Cloudflare provider v5''s `cloudflare_dns_record` doesn''t support `allow_overwrite`\n\n## How it works\n1. Before creating CNAME records, the provisioner queries Cloudflare API for existing records\n2. If a record exists and it''s NOT already our tunnel CNAME, it deletes it\n3. Then `cloudflare_dns_record` creates the tunnel CNAME\n\n## Requirements\n- `CLOUDFLARE_API_TOKEN` environment variable must be set for local execution\n- `jq` must be available for JSON parsing\n\n## Test plan\n- [ ] Terraform plan shows `terraform_data.delete_existing_dns` creation\n- [ ] Terraform apply successfully deletes existing A record and creates CNAME\n- [ ] Subsequent applies don''t try to delete the CNAME we just created\n\nðŸ¤– Generated with [Claude Code]\\(https://claude.com/claude-code\\)\nEOF\n\\)\")",
      "Bash(gh pr close:*)",
      "Bash(git branch:*)",
      "Bash(cloudflared tunnel route dns:*)",
      "Bash(cloudflared tunnel info:*)",
      "Bash(dig +short:*)",
      "Bash(curl:*)",
      "Bash(cloudflared tunnel route:*)",
      "Bash(for host in hey.shrub.dev signoz.shrub.dev map.shrub.dev adguard.shrub.dev grafana.shrub.dev kube.shrub.dev emote.shrub.dev podinfo.shrub.dev)",
      "Bash(gh pr create:*)",
      "Bash(xargs -I{} sh -c 'echo \"\"$\\(basename {}\\): {}\"\"')",
      "Bash(kubectl version:*)",
      "Bash(helm version:*)",
      "Bash(ansible:*)",
      "Bash(cloudflared:*)",
      "Bash(tailscale version:*)",
      "Bash(gh --version:*)",
      "Bash(ssh:*)",
      "Bash(tailscale status:*)",
      "Bash(git rm:*)",
      "Bash(git remote set-url:*)",
      "Bash(export GIT_CONFIG_GLOBAL=~/.gitconfig-personal)",
      "Bash(gh auth status:*)",
      "Bash(gh auth:*)",
      "Bash(kubectl get:*)",
      "Bash(kubectl config get-contexts:*)",
      "Bash(KUBECONFIG=~/.kube/michael kubectl get:*)",
      "Bash(gh pr list:*)",
      "Bash(gh secret:*)",
      "Bash(KUBECONFIG=~/.kube/michael helm list:*)"
    ]
  }
}
