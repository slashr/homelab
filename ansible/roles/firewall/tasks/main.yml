---
# UFW Firewall Configuration for Public Cloud Nodes
# Adds rate limiting for SSH and restricts k3s traffic to Tailscale network

- name: Check for ufw binary
  ansible.builtin.command: command -v ufw
  register: ufw_binary_check
  changed_when: false
  failed_when: false
  become: true
  tags: [firewall, ufw]

- name: Install UFW (if missing)
  ansible.builtin.apt:
    name: ufw
    state: present
    update_cache: true
  environment:
    DEBIAN_FRONTEND: noninteractive
  become: true
  register: ufw_install
  retries: 3
  delay: 5
  until: ufw_install is success
  when: ufw_binary_check.rc != 0
  tags: [firewall, ufw]

- name: Reset connection after UFW install to refresh PATH
  ansible.builtin.meta: reset_connection
  when: ufw_install is changed
  tags: [firewall, ufw]

- name: Wait for ufw binary to be available
  ansible.builtin.wait_for:
    path: /usr/sbin/ufw
    state: present
    timeout: 10
  when: ufw_install is changed
  become: true
  tags: [firewall, ufw]

- name: Verify ufw binary works
  ansible.builtin.command: /usr/sbin/ufw --version
  register: ufw_version_check
  changed_when: false
  failed_when: ufw_version_check.rc != 0
  when: ufw_install is changed
  become: true
  tags: [firewall, ufw]

- name: Preseed iptables-persistent to skip interactive prompts
  ansible.builtin.debconf:
    name: iptables-persistent
    question: "{{ item }}"
    value: "false"
    vtype: boolean
  loop:
    - iptables-persistent/autosave_v4
    - iptables-persistent/autosave_v6
  become: true
  tags: [firewall, ufw]

- name: Install iptables-persistent
  ansible.builtin.apt:
    name: iptables-persistent
    state: present
  environment:
    DEBIAN_FRONTEND: noninteractive
  become: true
  tags: [firewall, ufw]

- name: Reset UFW to default state
  community.general.ufw:
    state: reset
  become: true
  tags: [firewall, ufw]

- name: Set UFW default incoming policy to deny
  community.general.ufw:
    default: deny
    direction: incoming
  become: true
  tags: [firewall, ufw]

- name: Set UFW default outgoing policy to allow
  community.general.ufw:
    default: allow
    direction: outgoing
  become: true
  tags: [firewall, ufw]

- name: Set UFW default routed/forward policy to allow (required for k3s)
  community.general.ufw:
    default: allow
    direction: routed
  become: true
  tags: [firewall, ufw]

- name: Allow Tailscale (41641/udp) - MUST be before enabling firewall
  community.general.ufw:
    rule: allow
    port: '41641'
    proto: udp
  become: true
  tags: [firewall, ufw]

- name: Allow SSH with rate limiting (22/tcp) - max 6 connections per 30s
  community.general.ufw:
    rule: limit
    port: '22'
    proto: tcp
  become: true
  tags: [firewall, ufw]

- name: Allow k3s API server (6443/tcp) from Tailscale network only
  community.general.ufw:
    rule: allow
    port: '6443'
    proto: tcp
    from_ip: "{{ tailscale_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow kubelet (10250/tcp) from Tailscale network only
  community.general.ufw:
    rule: allow
    port: '10250'
    proto: tcp
    from_ip: "{{ tailscale_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow k3s metrics (10251/tcp) from Tailscale network only
  community.general.ufw:
    rule: allow
    port: '10251'
    proto: tcp
    from_ip: "{{ tailscale_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow flannel VXLAN (8472/udp) from Tailscale network only
  community.general.ufw:
    rule: allow
    port: '8472'
    proto: udp
    from_ip: "{{ tailscale_network_cidr }}"
  become: true
  tags: [firewall, ufw]

# Allow pod/service CIDRs so cross-node traffic isn't blocked by ufw-not-local
- name: Allow pod network (10.42.0.0/16) from cluster
  community.general.ufw:
    rule: allow
    from_ip: "{{ pod_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow pod network (10.42.0.0/16) to cluster
  community.general.ufw:
    rule: allow
    to_ip: "{{ pod_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow service network (10.43.0.0/16) from cluster
  community.general.ufw:
    rule: allow
    from_ip: "{{ service_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow service network (10.43.0.0/16) to cluster
  community.general.ufw:
    rule: allow
    to_ip: "{{ service_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Enable UFW (forced, non-interactive)
  community.general.ufw:
    state: enabled
  become: true
  tags: [firewall, ufw]

- name: Check for flannel subnet file
  ansible.builtin.stat:
    path: /run/flannel/subnet.env
  register: flannel_subnet_file
  changed_when: false
  become: true
  tags: [firewall, ufw, tailscale]

- name: Read flannel subnet
  ansible.builtin.shell: . /run/flannel/subnet.env && echo "${FLANNEL_SUBNET}"
  register: flannel_subnet
  changed_when: false
  become: true
  when: flannel_subnet_file.stat.exists
  tags: [firewall, ufw, tailscale]

- name: Check MASQUERADE for pod subnet over tailscale0
  ansible.builtin.command: iptables -t nat -C POSTROUTING -s {{ flannel_subnet.stdout }} ! -d {{ flannel_subnet.stdout }} -o tailscale0 -j MASQUERADE
  register: tailscale_masq_check
  changed_when: false
  failed_when: false
  become: true
  when: flannel_subnet_file.stat.exists
  tags: [firewall, ufw, tailscale]

- name: Add MASQUERADE for pod subnet over tailscale0
  ansible.builtin.command: iptables -t nat -I POSTROUTING 1 -s {{ flannel_subnet.stdout }} ! -d {{ flannel_subnet.stdout }} -o tailscale0 -j MASQUERADE
  become: true
  register: tailscale_masq_add
  changed_when: true
  when:
    - flannel_subnet_file.stat.exists
    - tailscale_masq_check.rc != 0
  tags: [firewall, ufw, tailscale]

- name: Check for Tailscale interface
  ansible.builtin.command: ip link show tailscale0
  register: tailscale0_check
  changed_when: false
  failed_when: false
  become: true
  tags: [firewall, ufw, tailscale]

- name: Check TCPMSS set on tailscale0 output
  ansible.builtin.command: iptables -t mangle -C OUTPUT -o tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss {{ tailscale_mss }}
  register: tailscale_mss_set_check
  changed_when: false
  failed_when: false
  become: true
  when: tailscale0_check.rc == 0
  tags: [firewall, ufw, tailscale]

- name: Set TCPMSS on tailscale0 output
  ansible.builtin.command: iptables -t mangle -I OUTPUT 1 -o tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss {{ tailscale_mss }}
  become: true
  register: tailscale_mss_set_add
  changed_when: true
  when:
    - tailscale0_check.rc == 0
    - tailscale_mss_set_check.rc != 0
  tags: [firewall, ufw, tailscale]

- name: Check TCPMSS clamp on tailscale0 egress
  ansible.builtin.command: iptables -t mangle -C FORWARD -o tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
  register: tailscale_mss_out_check
  changed_when: false
  failed_when: false
  become: true
  when: tailscale0_check.rc == 0
  tags: [firewall, ufw, tailscale]

- name: Add TCPMSS clamp on tailscale0 egress
  ansible.builtin.command: iptables -t mangle -I FORWARD 1 -o tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
  become: true
  register: tailscale_mss_out_add
  changed_when: true
  when:
    - tailscale0_check.rc == 0
    - tailscale_mss_out_check.rc != 0
  tags: [firewall, ufw, tailscale]

- name: Check TCPMSS clamp on tailscale0 ingress
  ansible.builtin.command: iptables -t mangle -C FORWARD -i tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
  register: tailscale_mss_in_check
  changed_when: false
  failed_when: false
  become: true
  when: tailscale0_check.rc == 0
  tags: [firewall, ufw, tailscale]

- name: Add TCPMSS clamp on tailscale0 ingress
  ansible.builtin.command: iptables -t mangle -I FORWARD 1 -i tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
  become: true
  register: tailscale_mss_in_add
  changed_when: true
  when:
    - tailscale0_check.rc == 0
    - tailscale_mss_in_check.rc != 0
  tags: [firewall, ufw, tailscale]

- name: Persist iptables rules
  ansible.builtin.command: netfilter-persistent save
  become: true
  when: >-
    (tailscale_masq_add is defined and tailscale_masq_add.changed) or
    (tailscale_mss_set_add is defined and tailscale_mss_set_add.changed) or
    (tailscale_mss_out_add is defined and tailscale_mss_out_add.changed) or
    (tailscale_mss_in_add is defined and tailscale_mss_in_add.changed)
  tags: [firewall, ufw, tailscale]

- name: Verify UFW is active
  ansible.builtin.command: ufw status verbose
  register: ufw_status
  changed_when: false
  become: true
  tags: [firewall, ufw]

- name: Display UFW status
  ansible.builtin.debug:
    var: ufw_status.stdout_lines
  tags: [firewall, ufw]

- name: Verify Tailscale connectivity (ping k3s master)
  ansible.builtin.command: ping -c 3 {{ k3s_master_ip }}
  register: tailscale_ping
  changed_when: false
  failed_when: false
  tags: [firewall, ufw]

- name: Display Tailscale connectivity status
  ansible.builtin.debug:
    msg: "Tailscale connectivity: {{ 'OK' if tailscale_ping.rc == 0 else 'FAILED - Check Tailscale!' }}"
  tags: [firewall, ufw]
