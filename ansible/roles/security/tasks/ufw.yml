---
# UFW Firewall Configuration for Raspberry Pis
# Configures firewall rules to allow k3s, SSH, Tailscale, and Pi services
# DNS/HTTP/HTTPS allowed from local network + Tailscale for flexibility

- name: Check for ufw binary
  ansible.builtin.command: command -v ufw
  register: ufw_binary_check
  changed_when: false
  failed_when: false
  become: true
  tags: [firewall, ufw]

- name: Install UFW (if missing)
  ansible.builtin.apt:
    name: ufw
    state: present
    update_cache: true
  environment:
    DEBIAN_FRONTEND: noninteractive
  become: true
  register: ufw_install
  retries: 3
  delay: 5
  until: ufw_install is success
  when: ufw_binary_check.rc != 0
  tags: [firewall, ufw]

# iptables-persistent conflicts with UFW on Debian Trixie - skip on Trixie
- name: Preseed iptables-persistent to skip interactive prompts
  ansible.builtin.debconf:
    name: iptables-persistent
    question: "{{ item }}"
    value: "false"
    vtype: boolean
  loop:
    - iptables-persistent/autosave_v4
    - iptables-persistent/autosave_v6
  become: true
  when: not (ansible_distribution == "Debian" and ansible_distribution_release == "trixie")
  tags: [firewall, ufw]

- name: Install iptables-persistent (not on Debian Trixie - conflicts with UFW)
  ansible.builtin.apt:
    name: iptables-persistent
    state: present
  environment:
    DEBIAN_FRONTEND: noninteractive
  become: true
  register: iptables_persistent_install
  when: not (ansible_distribution == "Debian" and ansible_distribution_release == "trixie")
  tags: [firewall, ufw]

- name: Reset UFW to default state
  community.general.ufw:
    state: reset
  become: true
  tags: [firewall, ufw]

- name: Set UFW default incoming policy to deny
  community.general.ufw:
    default: deny
    direction: incoming
  become: true
  tags: [firewall, ufw]

- name: Set UFW default outgoing policy to allow
  community.general.ufw:
    default: allow
    direction: outgoing
  become: true
  tags: [firewall, ufw]

- name: Set UFW default routed/forward policy to allow (required for k3s)
  community.general.ufw:
    default: allow
    direction: routed
  become: true
  tags: [firewall, ufw]

- name: Allow SSH (22/tcp) from local network
  community.general.ufw:
    rule: allow
    port: '22'
    proto: tcp
    from_ip: "{{ local_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow SSH (22/tcp) from Tailscale network
  community.general.ufw:
    rule: allow
    port: '22'
    proto: tcp
    from_ip: "{{ tailscale_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow Tailscale (41641/udp)
  community.general.ufw:
    rule: allow
    port: '41641'
    proto: udp
  become: true
  tags: [firewall, ufw]

- name: Allow k3s API server (6443/tcp) from Tailscale network
  community.general.ufw:
    rule: allow
    port: '6443'
    proto: tcp
    from_ip: "{{ tailscale_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow kubelet (10250/tcp) from Tailscale network
  community.general.ufw:
    rule: allow
    port: '10250'
    proto: tcp
    from_ip: "{{ tailscale_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow k3s node metrics (10250/tcp) from Tailscale network
  community.general.ufw:
    rule: allow
    port: '10251'
    proto: tcp
    from_ip: "{{ tailscale_network_cidr }}"
  become: true
  tags: [firewall, ufw]

# Allow pod/service CIDRs so cross-node traffic isn't blocked by ufw-not-local
- name: Allow pod network (10.42.0.0/16) from cluster
  community.general.ufw:
    rule: allow
    from_ip: "{{ pod_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow pod network (10.42.0.0/16) to cluster
  community.general.ufw:
    rule: allow
    to_ip: "{{ pod_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow service network (10.43.0.0/16) from cluster
  community.general.ufw:
    rule: allow
    from_ip: "{{ service_network_cidr }}"
  become: true
  tags: [firewall, ufw]

- name: Allow service network (10.43.0.0/16) to cluster
  community.general.ufw:
    rule: allow
    to_ip: "{{ service_network_cidr }}"
  become: true
  tags: [firewall, ufw]

# Raspberry Pi services - DNS, HTTP, HTTPS from local network + Tailscale
# Applied to ALL Pis for flexibility (e.g., AdGuard can move between nodes)
- name: Allow DNS (53/tcp+udp) from local network
  community.general.ufw:
    rule: allow
    port: '53'
    proto: "{{ item }}"
    from_ip: "{{ local_network_cidr }}"
  loop: [tcp, udp]
  become: true
  when: ufw_allow_dns | default(false)
  tags: [firewall, ufw, dns]

- name: Allow DNS (53/tcp+udp) from Tailscale network
  community.general.ufw:
    rule: allow
    port: '53'
    proto: "{{ item }}"
    from_ip: "{{ tailscale_network_cidr }}"
  loop: [tcp, udp]
  become: true
  when: ufw_allow_dns | default(false)
  tags: [firewall, ufw, dns]

- name: Allow HTTP (80/tcp) from local network
  community.general.ufw:
    rule: allow
    port: '80'
    proto: tcp
    from_ip: "{{ local_network_cidr }}"
  become: true
  when: ufw_allow_http | default(false)
  tags: [firewall, ufw, http]

- name: Allow HTTP (80/tcp) from Tailscale network
  community.general.ufw:
    rule: allow
    port: '80'
    proto: tcp
    from_ip: "{{ tailscale_network_cidr }}"
  become: true
  when: ufw_allow_http | default(false)
  tags: [firewall, ufw, http]

- name: Allow HTTPS (443/tcp) from local network
  community.general.ufw:
    rule: allow
    port: '443'
    proto: tcp
    from_ip: "{{ local_network_cidr }}"
  become: true
  when: ufw_allow_https | default(false)
  tags: [firewall, ufw, https]

- name: Allow HTTPS (443/tcp) from Tailscale network
  community.general.ufw:
    rule: allow
    port: '443'
    proto: tcp
    from_ip: "{{ tailscale_network_cidr }}"
  become: true
  when: ufw_allow_https | default(false)
  tags: [firewall, ufw, https]

- name: Enable UFW
  community.general.ufw:
    state: enabled
  become: true
  tags: [firewall, ufw]

# Tailscale iptables rules for cross-node pod traffic
- name: Check for flannel subnet file
  ansible.builtin.stat:
    path: /run/flannel/subnet.env
  register: flannel_subnet_file
  changed_when: false
  become: true
  tags: [firewall, ufw, tailscale]

- name: Read flannel subnet
  ansible.builtin.shell: . /run/flannel/subnet.env && echo "${FLANNEL_SUBNET}"
  register: flannel_subnet
  changed_when: false
  become: true
  when: flannel_subnet_file.stat.exists
  tags: [firewall, ufw, tailscale]

- name: Check MASQUERADE for pod subnet over tailscale0
  ansible.builtin.command: iptables -t nat -C POSTROUTING -s {{ flannel_subnet.stdout }} ! -d {{ flannel_subnet.stdout }} -o tailscale0 -j MASQUERADE
  register: tailscale_masq_check
  changed_when: false
  failed_when: false
  become: true
  when: flannel_subnet_file.stat.exists
  tags: [firewall, ufw, tailscale]

- name: Add MASQUERADE for pod subnet over tailscale0
  ansible.builtin.command: iptables -t nat -I POSTROUTING 1 -s {{ flannel_subnet.stdout }} ! -d {{ flannel_subnet.stdout }} -o tailscale0 -j MASQUERADE
  become: true
  register: tailscale_masq_add
  changed_when: true
  when:
    - flannel_subnet_file.stat.exists
    - tailscale_masq_check.rc != 0
  tags: [firewall, ufw, tailscale]

- name: Check for Tailscale interface
  ansible.builtin.command: ip link show tailscale0
  register: tailscale0_check
  changed_when: false
  failed_when: false
  become: true
  tags: [firewall, ufw, tailscale]

- name: Check TCPMSS set on tailscale0 output
  ansible.builtin.command: iptables -t mangle -C OUTPUT -o tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss {{ tailscale_mss }}
  register: tailscale_mss_set_check
  changed_when: false
  failed_when: false
  become: true
  when: tailscale0_check.rc == 0
  tags: [firewall, ufw, tailscale]

- name: Set TCPMSS on tailscale0 output
  ansible.builtin.command: iptables -t mangle -I OUTPUT 1 -o tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss {{ tailscale_mss }}
  become: true
  register: tailscale_mss_set_add
  changed_when: true
  when:
    - tailscale0_check.rc == 0
    - tailscale_mss_set_check.rc != 0
  tags: [firewall, ufw, tailscale]

- name: Check TCPMSS clamp on tailscale0 egress
  ansible.builtin.command: iptables -t mangle -C FORWARD -o tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
  register: tailscale_mss_out_check
  changed_when: false
  failed_when: false
  become: true
  when: tailscale0_check.rc == 0
  tags: [firewall, ufw, tailscale]

- name: Add TCPMSS clamp on tailscale0 egress
  ansible.builtin.command: iptables -t mangle -I FORWARD 1 -o tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
  become: true
  register: tailscale_mss_out_add
  changed_when: true
  when:
    - tailscale0_check.rc == 0
    - tailscale_mss_out_check.rc != 0
  tags: [firewall, ufw, tailscale]

- name: Check TCPMSS clamp on tailscale0 ingress
  ansible.builtin.command: iptables -t mangle -C FORWARD -i tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
  register: tailscale_mss_in_check
  changed_when: false
  failed_when: false
  become: true
  when: tailscale0_check.rc == 0
  tags: [firewall, ufw, tailscale]

- name: Add TCPMSS clamp on tailscale0 ingress
  ansible.builtin.command: iptables -t mangle -I FORWARD 1 -i tailscale0 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
  become: true
  register: tailscale_mss_in_add
  changed_when: true
  when:
    - tailscale0_check.rc == 0
    - tailscale_mss_in_check.rc != 0
  tags: [firewall, ufw, tailscale]

- name: Persist iptables rules (only when iptables-persistent is installed)
  ansible.builtin.command: netfilter-persistent save
  become: true
  when:
    - iptables_persistent_install is defined
    - iptables_persistent_install is not skipped
    - >-
      (tailscale_masq_add is defined and tailscale_masq_add.changed) or
      (tailscale_mss_set_add is defined and tailscale_mss_set_add.changed) or
      (tailscale_mss_out_add is defined and tailscale_mss_out_add.changed) or
      (tailscale_mss_in_add is defined and tailscale_mss_in_add.changed)
  tags: [firewall, ufw, tailscale]

- name: Verify UFW is active
  ansible.builtin.command: ufw status verbose
  register: ufw_status
  changed_when: false
  become: true
  tags: [firewall, ufw]

- name: Display UFW status
  ansible.builtin.debug:
    var: ufw_status.stdout_lines
  tags: [firewall, ufw]
